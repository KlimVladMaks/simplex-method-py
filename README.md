# Задание №1. Разработка программного обеспечения для решения задачи линейного программирования

## Ф.И.О.

Клименков Владислав Максимович

## Поток

МЕТОПТ 1.2

## Краткое описание механизмов работы программы

### Источник используемого алгоритма

Алгоритм решения ЗЛП, реализованный в рамках данной программы, основан на алгоритме, описанном на следующем [сайте](https://programforyou.ru/calculators/simplex-method).

### Формат ввода данных

Программа получает ЗЛП, считывая её из txt-файла. ЗЛП в txt-файле должна быть представлена в соответствующем формате. Например, следующую ЗЛП:

![](./images/1.png)

нужно будет записать в txt-файле в следующем формате:

```
2x1 +3x2 +x3 +4x4 -> max
x1 +x2 +x3 +x4 <= 10
2x1 +x2 -x3 +x4 = 8
x2 +2x3 +x4 >= 5
```

Стоит отметить, что программа способна распознавать несколько форматов ввода переменных. Например, следующие форматы ввода являются равнозначными:

```
+1x1 == 1x1 == +x1 == x1
-1x2 == -x2
+5x3 == 5x3
```

Таким образом, пример выше можно записать так:

```
+2x1 +3x2 +x3 +4x4 -> max
+1x1 +1x2 +1x3 +1x4 <= 10
+2x1 +1x2 -1x3 +1x4 = 8
+1x2 +2x3 +1x4 >= 5
```

и он также будет корректно распознан.

Больше примеров ввода можно увидеть в тестовых txt-файлах в папке `tests_txt`.

### Парсинг входных данных

Для более наглядного рассмотрения механизма работы программы, возьмём в качестве примера ЗЛП, упомянутую выше:

```
2x1 +3x2 +x3 +4x4 -> max
x1 +x2 +x3 +x4 <= 10
2x1 +x2 -x3 +x4 = 8
x2 +2x3 +x4 >= 5
```

После получения данной ЗЛП в формате txt-файла, программа преобразует его в более удобный для дальнейшей работы формат, состоящий из следующих компонентов:

```python
# Список коэффициентов целевой функции
objective_coefficients = [2, 3, 1, 4]

# Направление оптимизации ('max' или 'min')
objective_sense = "max"

# Матрица с коэффициентами ограничений
constraint_matrix = [
    [1, 1, 1, 1],
    [2, 1, -1, 1],
    [0, 1, 2, 1]
]

# Список с операторами ограничений ('>=', '<=', '=')
constraint_senses = ("<=", "=", ">=")

# Список с правыми частями ограничений
constraint_rhs = [10, 8, 5]
```

### Преобразование к канонической форме

Далее при наличии в ЗЛП ограничений с операторами `<=` и (или) `>=` программа приводит ЗЛП к каноническому виду с помощью добавления дополнительных переменных и, при необходимости, домножения на `-1`. В результате ЗЛП, рассматриваемая выше, преобразуется в единую таблицу следующего вида:

```
canonical_problem_table = [
    [2, 3, 1, 4, 0, 0, 'max'],
    [1, 1, 1, 1, 1, 0, 10],
    [2, 1, -1, 1, 0, 0, 8],
    [0, -1, -2, -1, 0, 1, -5]
]
```

которая задаёт канонический вид ЗЛП. Например, таблица выше задаёт параметры для канонической ЗЛП следующего вида:

```
2x1 +3x2 +1x3 +4x4 -> max
1x1 +1x2 +1x3 +1x4 +1x5 = 10
2x1 +1x2 -1x3 +1x4 = 8
-1x2 -2x3 -1x4 +1x6 = -5
```

### Формирование базиса

В пункте выше, если имело место быть добавление дополнительных переменных (если среди ограничений были операторы '>=' или '<='), то добавленные переменные становятся базисными для соответствующих строк. Например, для ЗЛП выше:

```
canonical_problem_table = [
    [2,  3,  1,  4, 0, 0, 'max'],
    [1,  1,  1,  1, 1, 0, 10],
    [2,  1, -1,  1, 0, 0,  8],
    [0, -1, -2, -1, 0, 1, -5]
]
```

уже на этапе составления канонической формы частично задаётся базис:

```
basis_indexes = [4, None, 5]
```

Как можно заметить, базисными являются переменные `x4` и `x5` для первой и третей строк ограничений соответственно. В то же время для второй строки ограничения базисная переменная пока не задана.

Далее каноническая форма ЗЛП разбивается на направление оптимизации, коэффициенты целевой функции и симплекс-таблицу, формируемую из коэффициентов (в том числе и правой части) ограничений:

```
# Направление оптимизации
obj = "max"

# Коэффициенты целевой функции
c = [2, 3, 1, 4, 0, 0]

# Симплекс-таблица
st = [
    [1,  1,  1,  1, 1, 0, 10],
    [2,  1, -1,  1, 0, 0,  8],
    [0, -1, -2, -1, 0, 1, -5]
]
```

Если базис на данный момент всё ещё неполный, то берётся первый подходящий столбец симплекс-таблицы и приводится к единичному виду (путём деления соответствующей строки и вычитания её из других строк). Таким образом формируется недостающий базис:

```
st = [
    [0.0,  0.5,  1.5,  0.5, 1.0, 0.0,  6.0],
    [1.0,  0.5, -0.5,  0.5, 0.0, 0.0,  4.0],
    [0.0, -1.0, -2.0, -1.0, 0.0, 1.0, -5.0]
]

basis_indexes = [4, 0, 5]
```

Теперь базис полностью сформирован.
